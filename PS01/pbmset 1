#######Problem 7

using Parameters, Plots #read in necessary packages



#a struct to hold model primitives.
@with_kw struct Primitives
    β::Float64 = 0.99 #discount rate.
    θ::Float64 = 0.36 #capital share
    δ::Float64 = 0.025 #capital depreciation
    k_grid::Array{Float64,1} = collect(range(0.01, length = 1000, stop = 75.0)) #capital grid
    nk::Int64 = length(k_grid) #number of capital elements
    markov::Array{Float64,2} = [0.977 0.023; 0.074 0.926] #markov transition process
    z_grid::Array{Float64,1} = [1.25, 0.2] #productivity state grid
    nz::Int64 = length(z_grid) #number of productivity states
end

#mutable struct to hold model results
mutable struct Results
    val_func::Array{Float64,2}
    pol_func::Array{Float64,2}
end

#function that executes the model and returns results
function Solve_model()
    prim = Primitives() #initialize primitives
    val_func = zeros(prim.nk, prim.nz) #preallocate value function as a vector of zeros
    pol_func = zeros(prim.nk, prim.nz) #preallocate value function as a vector of zeros
    res = Results(val_func, pol_func) #initialize results
    V_iterate(prim, res) #value function iteration
    prim, res #return deliverables
end


#value function iteration program. Note that we do EVERYTHING in functions, handling as few global
function V_iterate(prim::Primitives, res::Results; tol::Float64 = 1e-4)
    error = 100 #starting error
    n = 0 #counter
    while error>tol #main convergence loop
        n+=1
        v_next = Bellman(prim, res) #execute Bellman operator
        error = maximum(abs.(v_next - res.val_func)) #reset error term
        res.val_func = v_next #update value function held in results vector
    end
    println("Value functions converged in ", n, " iterations.")
end



#Bellman operator
function Bellman(prim::Primitives, res::Results)
    @unpack β, δ, θ, nz, nk, z_grid, k_grid, markov = prim #unpack parameters from prim struct. Improves readability.
    v_next = zeros(nk, nz)

    for i_k = 1:nk, i_z = 1:nz #loop over state space
        candidate_max = -1e10 #something crappy
        k, z = k_grid[i_k], z_grid[i_z] #convert state indices to state values
        budget = z*k^θ + (1-δ)*k #budget given current state. Doesn't this look nice?

        for i_kp = 1:nk #loop over choice of k_prime
            kp = k_grid[i_kp]
            c = budget - kp #consumption
            if c>0 #check to make sure that consumption is positive
                val = log(c) + β * sum(res.val_func[i_kp,:].*markov[i_z, :])
                if val>candidate_max #check for new max value
                    candidate_max = val
                    res.pol_func[i_k, i_z] = kp #update policy function
                end
            end
        end
        v_next[i_k, i_z] = candidate_max #update next guess of value function
    end
    v_next
end

prim, res = Solve_model() #solve for policy and value functions

#unpack our results and make some plots
@unpack val_func, pol_func = res
@unpack k_grid = prim

#plot value function
Plots.plot(k_grid,val_func, title="Value Functions", label = ["Good State" "Bad State"])

Plots.savefig("C:/Users/sabrina bensaid/Desktop/Value_Functions.png")


#plot policy functions
Plots.plot(k_grid, pol_func, title="Policy Functions", label = ["Good State" "Bad State"])
Plots.savefig("C:/Users/sabrina bensaid/Desktop/Policy_Functions.png")

pol_func_δ = copy(pol_func).-k_grid
Plots.plot(k_grid, pol_func_δ, title="Policy Functions Changes")
Plots.savefig("C:/Users/sabrina bensaid/Desktop/Policy_Functions_Changes.png")
